# Реализация библиотеки `s21_containers`

## Цель проекта:
**Создать собственную библиотеку контейнерных классов на языке C++ без использования стандартной библиотеки шаблонов (STL). Реализация должна имитировать поведение стандартных контейнеров C++, таких как `vector`, `map`, `queue`, `stack` и других. Код должен быть оформлен в виде заголовочных файлов, поддерживать работу с итераторами и покрытие unit-тестами с использованием библиотеки GTest.**

---

## Основные контейнеры

### 1. **Vector** (`vector`)

`Vector` — это динамический массив. Контейнер позволяет хранить элементы одного типа и автоматически увеличивает свой размер при добавлении новых элементов. Он предоставляет быстрый доступ к элементам по индексу и эффективно работает с добавлением элементов в конец.

**Основные операции:**
- Доступ к элементам по индексу.
- Добавление элемента в конец.
- Удаление последнего элемента.
- Резервирование памяти для ускорения работы.

**Пример использования:**

```cpp
s21::vector<int> v;
v.push_back(10);
v.push_back(20);
std::cout << v[0] << std::endl;  // 10
```

### 2. **Map** (`map`)
`Map` — это ассоциативный контейнер, который хранит элементы в виде пар "ключ-значение". Ключи уникальны, и элементы упорядочиваются по ключу. Для поиска элементов используется алгоритм поиска по ключу, что делает его эффективным.

**Основные операции:**

- Вставка пар "ключ-значение".
- Поиск по ключу.
- Удаление элементов по ключу.
- Итерация по всем элементам в порядке возрастания ключей.

**Пример использования:**

```cpp
s21::map<int, std::string> m;
m.insert({1, "one"});
m.insert({2, "two"});
std::cout << m[1] << std::endl;  // "one"
```

### 4. **Stack** (`stack`)
`Stack` — это структура данных, основанная на принципе LIFO (Last In, First Out). Элементы добавляются и извлекаются только с одного конца.

**Основные операции:**

- Добавление элемента в верхушку стека.
- Извлечение элемента с верхушки.
- Проверка на пустоту.

**Пример использования:**

```cpp
s21::stack<int> s;
s.push(10);
s.push(20);
std::cout << s.top() << std::endl;  // 20
s.pop();
std::cout << s.top() << std::endl;  // 10
```

### 5. **Set** (`set`)
`Set` — это ассоциативный контейнер, который хранит уникальные элементы и автоматически их сортирует. В нем нельзя хранить дублирующиеся элементы.

**Основные операции:**

- Вставка элементов.
- Удаление элементов.
- Поиск элемента.

**Пример использования:**

```cpp
s21::set<int> s;
s.insert(10);
s.insert(20);
s.insert(10);  // Игнорируется, т.к. элемент уже есть
std::cout << (s.find(10) != s.end()) << std::endl;  // 1 (найден)
```

### 6. *List* (`list`)
`List` — это двусвязный список, который поддерживает вставку и удаление элементов в любом месте. Элементы могут быть вставлены или удалены в начале, в середине или в конце списка.

**Основные операции:**

- Вставка элемента в начало или в конец.
- Удаление элемента.
- Итерация по элементам.

**Пример использования:**

```cpp
s21::list<int> l;
l.push_back(10);
l.push_front(5);
std::cout << l.front() << std::endl;  // 5
```

## Дополнительные контейнеры
### 1. **Array** (`array`)
`Array` — это контейнер фиксированного размера, который хранит элементы в последовательной области памяти. Его размер известен на этапе компиляции и не может изменяться.

**Основные операции:**

- Доступ к элементам по индексу.
- Проверка на переполнение (если необходимо).

**Пример использования:**

```cpp
s21::array<int, 5> arr;
arr[0] = 10;
std::cout << arr[0] << std::endl;  // 10
```

### 2. **Multiset** (`multiset`)
`Multiset` — это ассоциативный контейнер, похожий на set, но допускающий хранение одинаковых элементов. Элементы автоматически сортируются.

**Основные операции:**

- Вставка нескольких одинаковых элементов.
- Удаление элементов.
- Поиск элемента.

**Пример использования:**

```cpp
s21::multiset<int> ms;
ms.insert(10);
ms.insert(20);
ms.insert(10);
std::cout << ms.count(10) << std::endl;  // 2 (элементов 10)
```

# Методы вставки `insert_many`
### 1. **insert_many** (List, Vector)
Метод вставляет несколько элементов в контейнер перед указанной позицией. Элементы передаются через параметр `pack Args&&... args`.

**Пример использования:**

```cpp
s21::vector<int> v;
v.insert_many(v.begin(), 10, 20, 30);
```

### 2. **insert_many_back** (List, Vector, Queue, Stack)
Метод добавляет несколько элементов в конец контейнера.

**Пример использования:**

```cpp
s21::queue<int> q;
q.insert_many_back(10, 20, 30);
```

### 3. **insert_many_front** (List)
Метод добавляет несколько элементов в начало контейнера.

**Пример использования:**

```cpp
s21::list<int> l;
l.insert_many_front(10, 20, 30);
```

### 4. **insert_many** (Map, Set, Multiset)
Метод вставляет несколько пар элементов или ключ-значение в контейнер.

**Пример использования:**

```cpp
s21::map<int, std::string> m;
m.insert_many({{1, "one"}, {2, "two"}});
```

---

## Технические требования

- **Язык программирования:** C++ (стандарт C++17)
- **Поддержка компилятора:** GCC
- **Стиль кодирования:** Google Style
- **Используемые библиотеки:** GTest (для unit-тестов)
- **Пространство имен:** s21
- **Поддерживаемые контейнеры:**
  - `vector`
  - `map`
  - `queue`
  - `stack`
  - `set`
  - `list`
  - `array`
  - `multiset`

---

## Makefile

Для тестирования и сборки библиотеки необходимо подготовить Makefile:

```makefile
CC=gcc
CFLAGS= -std=c++17 -pedantic -Wall -Werror -Wextra
TARGET = s21_containers_test

# Директория для тестов
TEST_DIR=./test/
TEST_FILES=$(wildcard $(TEST_DIR)*.cc)
OUT_TEST=$(TEST_DIR)$(TARGET)
OS := $(shell uname -s)

# Флаги для линукса отдельно
ifeq ($(OS),Linux)
	OPEN_CMD = xdg-open
	TEST_LIBS = -lgtest -pthread -lstdc++ -lsubunit -lrt -lm
endif
ifeq ($(OS),Darwin)
	OPEN_CMD = open
	TEST_LIBS =-ld64 -lgtest -pthread -lstdc++
endif

SRC = test/*.cc
INCLUDES = -I./src

all: clean $(TARGET)

$(TARGET): clean $(SRC)
	$(CC) $(CFLAGS) $(SRC) $(INCLUDES) -o $(OUT_TEST) $(TEST_LIBS)

test: rebuild
	${OUT_TEST}
	
%.o: %.cc
	$(CC) $(CFLAGS) -c $< -o $@

gcov_report: clean
	$(CC) $(CFLAGS) --coverage -o $(TEST_DIR)gtest_test $(TEST_FILES) $(TEST_LIBS)
	chmod +x $(TEST_DIR)gtest_test
	$(TEST_DIR)gtest_test
	lcov --capture --directory . --rc branch_coverage=0 --output-file $(TEST_DIR)coverage.info \
		--ignore-errors=mismatch,inconsistent \
		--exclude '*/test/*' --exclude '*/usr/*'
	genhtml $(TEST_DIR)coverage.info --output-directory $(TEST_DIR)coverage_report --rc branch_coverage=0
	$(OPEN_CMD) $(TEST_DIR)coverage_report/index.html

valgrind: rebuild
	valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=leaks_log.txt $(OUT_TEST)
	echo --- Valgrind summary --- && cat leaks_log.txt | grep 'total heap usage' && cat leaks_log.txt | grep 'ERROR SUMMARY'

clean: clean_test
	rm -rf *.o */*.o $(TARGET) */$(TARGET) *.out *.dSYM report debug test.out leaks_log.txt

clean_test:
	rm -rf $(TEST_DIR)*.gc* $(TEST_DIR)*.info $(TEST_DIR)gtest_test $(TEST_DIR)coverage_report $(TEST_DIR)*.out $(TEST_DIR)*.out.* $(TEST_DIR)gtest_test.dSYM/ $(TEST_DIR)*.gcda

rebuild: clean $(TARGET)
```

---

## Заключение

В рамках данного проекта была реализована собственная библиотека контейнеров на языке C++, которая включает в себя основные типы данных, такие как `vector`, `map`, `queue`, `stack`, `set`, `list`, а также дополнительные контейнеры, включая `array` и `multiset`. Особое внимание уделено производительности и корректности реализации, что позволило достичь высокого уровня стабильности и удобства при работе с контейнерами.

Библиотека полностью совместима с компилятором GCC и использует стандарт C++17, что делает её актуальной для большинства современных C++-проектов. Все операции, такие как вставка, удаление, поиск и итерация, были реализованы с учётом лучших практик для оптимизации скорости работы контейнеров.

Важной частью проекта является интеграция с GTest для проведения unit-тестирования, что позволяет обеспечить высокое качество кода и минимизировать возможные ошибки. Благодаря этому, разработка и использование библиотеки становятся более предсказуемыми и безопасными.

Кроме того, реализованный `Makefile` позволяет легко компилировать проект, запускать тесты и поддерживать порядок в процессе разработки. Вы можете использовать эту библиотеку в своих проектах, расширять её функционал или адаптировать под свои нужды, соблюдая стандарт Google Style, что способствует улучшению читаемости и поддержки кода.

Библиотека контейнеров от `s21` предоставляет удобный и мощный инструментарий для работы с данными в C++ и будет полезна как для начинающих, так и для опытных разработчиков, стремящихся создавать высококачественные и масштабируемые приложения.

---
